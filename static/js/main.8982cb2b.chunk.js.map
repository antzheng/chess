{"version":3,"sources":["components/ChessPage/utils/ChessPageConstants.js","styles/assets/images/bishop-dark.svg","styles/assets/images/king-dark.svg","styles/assets/images/knight-dark.svg","styles/assets/images/pawn-dark.svg","styles/assets/images/queen-dark.svg","styles/assets/images/rook-dark.svg","styles/assets/images/bishop-light.svg","styles/assets/images/king-light.svg","styles/assets/images/knight-light.svg","styles/assets/images/pawn-light.svg","styles/assets/images/queen-light.svg","styles/assets/images/rook-light.svg","components/ChessPage/utils/ChessMovements.js","components/ChessPage/utils/ChessPageUtils.js","components/ChessPage/Board.js","views/ChessPage.js","App.js","index.js"],"names":["SVGMap","bishopDark","kingDark","knightDark","pawnDark","queenDark","rookDark","bishopLight","kingLight","knightLight","pawnLight","queenLight","rookLight","ChessEnum","ROOK","KNIGHT","BISHOP","QUEEN","KING","PAWN","LIGHT","DARK","pawnRow","Array","fill","backRow","DEFAULT","map","pieces","SIZE","getAvailableMoves","piece","row","col","color","board","initial","checkCastle","moveHandler","bishop","availableBishopMoves","king","availableKingMoves","knight","availableKnightMoves","pawn","availablePawnMoves","queen","availableQueenMoves","rook","availableRookMoves","generatePossibleMoves","directions","expand","possible","upperBound","forEach","dx","dy","i","x","y","isOutOfBounds","getPieceFromXY","targetColor","isValidPiece","push","filter","newBoard","generateNewBoard","isInCheck","notMoved","targetPiece","forward","kingUnmoved","flipped","flipBoard","isValidCastlePosition","isLeftSide","direction","once","twice","some","availableMoves","j","split","Object","values","includes","reverse","startX","startY","endX","endY","copy","startPiece","startColor","isCheckMate","kingCoords","opposing","supporting","side","simulated","coords","moves","length","threatening","getTileColor","isActiveTile","activeRow","activeCol","getImageSrc","key","charAt","toUpperCase","slice","choosePiece","props","boardHandler","isWhiteMove","turnHandler","setActiveTile","activeHandler","setAvailableMoves","previewHandler","movePiece","rowInit","colInit","rowDest","colDest","setIsWhiteMove","boardState","setBoardState","setPromotionTile","promotionHandler","rookCol","ChessPiece","isDraggable","ChessPageUtils","className","draggable","src","alt","PromotionModal","promotionClickHandler","onClick","Board","useState","activeTile","hoveredTile","setHoveredTile","isCheck","setIsCheck","setIsCheckMate","promotionTile","text","style","_","currentTile","name","isActive","isHovered","onDragStart","onDragEnter","onDragEnd","onDragOver","e","preventDefault","ChessPage","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8982cb2b.chunk.js","sourcesContent":["/*\n--------------------------------------------------------------------------------------\n--------------------------------------- IMAGES ---------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\nimport bishopDark from './../../../styles/assets/images/bishop-dark.svg';\nimport kingDark from './../../../styles/assets/images/king-dark.svg';\nimport knightDark from './../../../styles/assets/images/knight-dark.svg';\nimport pawnDark from './../../../styles/assets/images/pawn-dark.svg';\nimport queenDark from './../../../styles/assets/images/queen-dark.svg';\nimport rookDark from './../../../styles/assets/images/rook-dark.svg';\nimport bishopLight from './../../../styles/assets/images/bishop-light.svg';\nimport kingLight from './../../../styles/assets/images/king-light.svg';\nimport knightLight from './../../../styles/assets/images/knight-light.svg';\nimport pawnLight from './../../../styles/assets/images/pawn-light.svg';\nimport queenLight from './../../../styles/assets/images/queen-light.svg';\nimport rookLight from './../../../styles/assets/images/rook-light.svg';\n\nexport const SVGMap = {\n  bishopDark,\n  kingDark,\n  knightDark,\n  pawnDark,\n  queenDark,\n  rookDark,\n  bishopLight,\n  kingLight,\n  knightLight,\n  pawnLight,\n  queenLight,\n  rookLight,\n};\n\n/*\n--------------------------------------------------------------------------------------\n------------------------------------- CONSTANTS --------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\nexport const ChessEnum = {\n  ROOK: 'rook',\n  KNIGHT: 'knight',\n  BISHOP: 'bishop',\n  QUEEN: 'queen',\n  KING: 'king',\n  PAWN: 'pawn',\n  LIGHT: 'light',\n  DARK: 'dark',\n};\n\nexport const SIZE = 8;\n\n/*\n--------------------------------------------------------------------------------------\n----------------------------------- DEFAULT BOARD ------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\nconst pawnRow = Array(SIZE).fill(ChessEnum.PAWN);\nconst backRow = [\n  ChessEnum.ROOK,\n  ChessEnum.KNIGHT,\n  ChessEnum.BISHOP,\n  ChessEnum.QUEEN,\n  ChessEnum.KING,\n  ChessEnum.BISHOP,\n  ChessEnum.KNIGHT,\n  ChessEnum.ROOK,\n];\n\nexport const DEFAULT = [\n  backRow.map((pieces) => pieces + '-dark-unmoved'),\n  pawnRow.map((pieces) => pieces + '-dark-unmoved'),\n  ...Array(SIZE - 4)\n    .fill()\n    .map(() => Array(SIZE).fill(null)),\n  pawnRow.map((pieces) => pieces + '-light-unmoved'),\n  backRow.map((pieces) => pieces + '-light-unmoved'),\n];\n","export default __webpack_public_path__ + \"static/media/bishop-dark.99ecd7c8.svg\";","export default __webpack_public_path__ + \"static/media/king-dark.044fe330.svg\";","export default __webpack_public_path__ + \"static/media/knight-dark.6383ac9d.svg\";","export default __webpack_public_path__ + \"static/media/pawn-dark.ce285b7c.svg\";","export default __webpack_public_path__ + \"static/media/queen-dark.35ebf88c.svg\";","export default __webpack_public_path__ + \"static/media/rook-dark.c65697c2.svg\";","export default __webpack_public_path__ + \"static/media/bishop-light.fb973169.svg\";","export default __webpack_public_path__ + \"static/media/king-light.f0c34dda.svg\";","export default __webpack_public_path__ + \"static/media/knight-light.00236166.svg\";","export default __webpack_public_path__ + \"static/media/pawn-light.8edd8ce1.svg\";","export default __webpack_public_path__ + \"static/media/queen-light.0e2777be.svg\";","export default __webpack_public_path__ + \"static/media/rook-light.2f973e2c.svg\";","/*\n--------------------------------------------------------------------------------------\n-------------------------------------- IMPORTS ---------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\nimport { SIZE } from './ChessPageConstants';\nimport {\n  flipBoard,\n  isInCheck,\n  isOutOfBounds,\n  isValidPiece,\n  generateNewBoard,\n  getPieceFromXY,\n} from './ChessPageUtils';\n\n/*\n--------------------------------------------------------------------------------------\n------------------------------------ GENERALIZED -------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\n// given a piece, position, color, and the board\n// return an array of coordinates representing available moves\nconst getAvailableMoves = (\n  piece,\n  row,\n  col,\n  color,\n  board,\n  initial = true,\n  checkCastle = true\n) => {\n  const moveHandler = {\n    bishop: availableBishopMoves,\n    king: availableKingMoves,\n    knight: availableKnightMoves,\n    pawn: availablePawnMoves,\n    queen: availableQueenMoves,\n    rook: availableRookMoves,\n  };\n  return moveHandler[piece](row, col, color, board, initial, checkCastle);\n};\n\n// given directions, a starting position, the color, and the board,\n// return a list of possible moves for this piece\nconst generatePossibleMoves = (\n  directions,\n  row,\n  col,\n  color,\n  board,\n  expand,\n  initial\n) => {\n  // possible moves\n  const possible = [];\n\n  // number of moves before stopping\n  const upperBound = expand ? 8 : 2;\n\n  // expand in each direction until hit piece or bounds\n  directions.forEach(([dx, dy]) => {\n    for (let i = 1; i < upperBound; i++) {\n      const [x, y] = [row + dx * i, col + dy * i];\n\n      // stop when out of bounds\n      if (isOutOfBounds(x, y)) return;\n\n      const [piece, targetColor] = getPieceFromXY(x, y, board);\n      const isBlocked = isValidPiece(piece);\n\n      // stop when blocked\n      if (isBlocked) {\n        if (targetColor !== color) possible.push([x, y]);\n        return;\n      }\n      possible.push([x, y]);\n    }\n  });\n\n  // prevent recursively checking\n  if (!initial) return possible;\n\n  // filter out all moves that would expose king to check\n  return possible.filter(([x, y]) => {\n    const newBoard = generateNewBoard(row, col, x, y, board);\n    return !isInCheck(color, newBoard);\n  });\n};\n\n/*\n--------------------------------------------------------------------------------------\n-------------------------------------- SPECIFIC --------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\n// a pawn can move:\n// - forward twice at the start\n// - forward once normally\n// - diagonally to take\n// - TODO: enpassant (diagonal if opponent pawn moved forward twice)\n// - TODO: promotion\nconst availablePawnMoves = (row, col, color, board, initial) => {\n  // possible moves\n  const possible = [];\n\n  // determine if still at beginning\n  const notMoved = row === 6;\n\n  // moving up (decreasing row index)\n  const direction = -1;\n\n  // handle diags\n  [\n    [row + direction, col - 1],\n    [row + direction, col + 1],\n  ].forEach(([x, y]) => {\n    // if out of bounds or empty, skip\n    if (isOutOfBounds(x, y)) return;\n\n    // if no pieces, can't move diagonally\n    const [targetPiece, targetColor] = getPieceFromXY(x, y, board);\n    if (targetPiece === null) return;\n\n    // if color is opposite, it means available\n    if (targetColor !== color) possible.push([x, y]);\n  });\n\n  // handle forward\n  const forward = [[row + direction, col]];\n\n  // can move twice if not moved and not blocked\n  if (notMoved) {\n    const [piece] = getPieceFromXY(...forward[0], board);\n    const blocked = isValidPiece(piece);\n    if (!blocked) forward.push([row + 2 * direction, col]);\n  }\n\n  // filter valid moves\n  forward.forEach(([x, y]) => {\n    // if out of bounds or empty, skip\n    if (isOutOfBounds(x, y)) return;\n\n    // if there is a piece, it is blocked\n    const [targetPiece] = getPieceFromXY(x, y, board);\n    if (targetPiece !== null) return;\n\n    // if not blocked, add\n    possible.push([x, y]);\n  });\n\n  // prevent recursively checking\n  if (!initial) return possible;\n\n  // filter out all moves that would expose king to check\n  return possible.filter(([x, y]) => {\n    const newBoard = generateNewBoard(row, col, x, y, board);\n    return !isInCheck(color, newBoard);\n  });\n};\n\n// bishops can move diagonally\nconst availableBishopMoves = (row, col, color, board, initial) => {\n  const directions = [\n    [-1, -1],\n    [-1, 1],\n    [1, -1],\n    [1, 1],\n  ];\n  return generatePossibleMoves(\n    directions,\n    row,\n    col,\n    color,\n    board,\n    true,\n    initial\n  );\n};\n\n// rooks can move vertically + horizontally\nconst availableRookMoves = (row, col, color, board, initial) => {\n  const directions = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n  ];\n  return generatePossibleMoves(\n    directions,\n    row,\n    col,\n    color,\n    board,\n    true,\n    initial\n  );\n};\n\n// queen can do bishop + rook moves\nconst availableQueenMoves = (row, col, color, board, initial) => {\n  const directions = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n    [-1, -1],\n    [-1, 1],\n    [1, -1],\n    [1, 1],\n  ];\n  return generatePossibleMoves(\n    directions,\n    row,\n    col,\n    color,\n    board,\n    true,\n    initial\n  );\n};\n\n// king moves around in all directions\nconst availableKingMoves = (\n  row,\n  col,\n  color,\n  board,\n  initial,\n  checkCastle = true\n) => {\n  const directions = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n    [-1, -1],\n    [-1, 1],\n    [1, -1],\n    [1, 1],\n  ];\n  const possible = generatePossibleMoves(\n    directions,\n    row,\n    col,\n    color,\n    board,\n    false,\n    initial\n  );\n\n  // deal with castling\n  const [, , kingUnmoved] = getPieceFromXY(row, col, board);\n\n  // generate simulated board\n  const flipped = flipBoard(board);\n\n  if (checkCastle && kingUnmoved && !isInCheck(color, flipped)) {\n    if (isValidCastlePosition(row, col, board, true, flipped))\n      possible.push([row, col - 2]);\n    if (isValidCastlePosition(row, col, board, false, flipped))\n      possible.push([row, col + 2]);\n  }\n\n  return possible;\n};\n\nconst isValidCastlePosition = (row, col, board, isLeftSide, flipped) => {\n  const rookCol = isLeftSide ? 0 : SIZE - 1;\n  const [, color, unmoved] = getPieceFromXY(row, rookCol, board);\n\n  // if rook is moved, can't castle this way\n  if (!unmoved) return false;\n\n  // define directions\n  const direction = isLeftSide ? -1 : 1;\n  const once = [row, col + direction];\n  const twice = [row, col + 2 * direction];\n\n  // spots must be empty\n  const occupied = [once, twice].some(([x, y]) => {\n    const [piece] = getPieceFromXY(x, y, board);\n    return isValidPiece(piece);\n  });\n  if (occupied) return false;\n\n  // can't move through check\n  const availableMoves = [];\n  for (let i = 0; i < SIZE; i++) {\n    for (let j = 0; j < SIZE; j++) {\n      const [targetPiece, targetColor] = getPieceFromXY(i, j, flipped);\n\n      // skip blank tiles\n      if (!isValidPiece(targetPiece)) continue;\n\n      // check opponent moves\n      if (color !== targetColor) {\n        availableMoves.push(\n          ...getAvailableMoves(\n            targetPiece,\n            i,\n            j,\n            targetColor,\n            flipped,\n            false,\n            false\n          )\n        );\n      }\n    }\n  }\n\n  // check if spots are in check\n  const spotInCheck = availableMoves.some(([x, y]) => {\n    x = SIZE - 1 - x;\n    y = SIZE - 1 - y;\n    return (\n      (x === once[0] && y === once[1]) || (x === twice[0] && y === twice[1])\n    );\n  });\n\n  // can castle if spots aren't in check\n  return !spotInCheck;\n};\n\n// knight moves in an L\nconst availableKnightMoves = (row, col, color, board, initial) => {\n  const directions = [\n    [-2, -1],\n    [-2, 1],\n    [-1, -2],\n    [-1, 2],\n    [1, -2],\n    [1, 2],\n    [2, -1],\n    [2, 1],\n  ];\n  return generatePossibleMoves(\n    directions,\n    row,\n    col,\n    color,\n    board,\n    false,\n    initial\n  );\n};\n\n/*\n--------------------------------------------------------------------------------------\n-------------------------------------- EXPORTS ---------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\nexport { getAvailableMoves };\n","/*\n--------------------------------------------------------------------------------------\n-------------------------------------- IMPORTS ---------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\nimport { SVGMap, ChessEnum, DEFAULT, SIZE } from './ChessPageConstants';\nimport { getAvailableMoves } from './ChessMovements';\n\n/*\n--------------------------------------------------------------------------------------\n-------------------------------------- UTILITY ---------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\n// given a coordinate, returns whether it is out of bounds\nconst isOutOfBounds = (row, col) => {\n  return row < 0 || row >= SIZE || col < 0 || col >= SIZE;\n};\n\n// given a coordinate, returns name, color, and if piece was unmoved\nconst getPieceFromXY = (x, y, board) => {\n  if (board[x][y] === null) return [null, null, null];\n  return board[x][y].split('-');\n};\n\n// given piece name, check if valid piece\nconst isValidPiece = (piece) => {\n  return piece !== null && Object.values(ChessEnum).includes(piece);\n};\n\n// given a board, flips it\nconst flipBoard = (board) => {\n  const flipped = board.map((row) => [...row]);\n  flipped.reverse();\n  flipped.forEach((row) => row.reverse());\n  return flipped;\n};\n\n// given start and end coords to move a piece\n// return new board (flipped)\nconst generateNewBoard = (startX, startY, endX, endY, board) => {\n  const copy = board.map((row) => [...row]);\n\n  // check enpassant\n  const [endPiece] = getPieceFromXY(endX, endY, copy);\n  if (endPiece === 'enpassant') copy[endX + 1][endY] = null;\n\n  // get rid of unmoved flag if there\n  const [startPiece, startColor] = getPieceFromXY(startX, startY, board);\n\n  copy[endX][endY] = startPiece + '-' + startColor;\n  copy[startX][startY] = null;\n  copy.reverse();\n  copy.forEach((row) => row.reverse());\n\n  // clear invalid pieces, reinforce empty tiles\n  for (let i = 0; i < SIZE; i++) {\n    for (let j = 0; j < SIZE; j++) {\n      const [piece] = getPieceFromXY(i, j, copy);\n      if (!isValidPiece(piece)) copy[i][j] = null;\n    }\n  }\n  return copy;\n};\n\n/*\nif can't move:\n  if more than 1 checking: checkmate\n  if can't take and can't block: checkmate\n*/\n// given a color and the board\n// and assuming the king is in check\n// return whether or not this is checkmate\nconst isCheckMate = (color, board) => {\n  // find the king and opposing pieces\n  let kingCoords = null;\n  const opposing = [];\n  const supporting = [];\n  const flipped = flipBoard(board);\n  for (let i = 0; i < SIZE; i++) {\n    for (let j = 0; j < SIZE; j++) {\n      const [targetPiece, targetColor] = getPieceFromXY(i, j, board);\n\n      // skip blank tiles\n      if (!isValidPiece(targetPiece)) continue;\n\n      // determine which side this piece is on\n      let side = opposing;\n      let simulated = board;\n      let [x, y] = [i, j];\n      if (targetColor === color) {\n        side = supporting;\n        simulated = flipped;\n        [x, y] = [SIZE - 1 - x, SIZE - 1 - y];\n      }\n\n      // add pieces\n      if (targetPiece !== ChessEnum.KING) {\n        side.push({\n          piece: targetPiece,\n          coords: [x, y],\n          moves: getAvailableMoves(targetPiece, x, y, targetColor, simulated),\n        });\n      }\n      // find our king\n      else if (targetColor === color) {\n        kingCoords = [i, j];\n      }\n    }\n  }\n\n  // check if king can move\n  const possible = getAvailableMoves(\n    ChessEnum.KING,\n    SIZE - 1 - kingCoords[0],\n    SIZE - 1 - kingCoords[1],\n    color,\n    flipped\n  );\n  if (possible.length === 0) {\n    // find the pieces that threaten the king\n    const threatening = [];\n    opposing.forEach(({ piece, coords, moves }) => {\n      // if this piece can move to where king is, it is checking the king\n      if (moves.some(([x, y]) => x === kingCoords[0] && y === kingCoords[1])) {\n        threatening.push({ piece, coords });\n      }\n    });\n\n    // checkmate if king can't move and multiple pieces check it\n    if (threatening.length > 1) return true;\n\n    // checkmate if threatening piece can't be taken or blocked\n    const canRemoveObstacle = supporting.some(({ coords, moves }) => {\n      const canTakeOrBlock = moves.some(([x, y]) => {\n        const newBoard = generateNewBoard(...coords, x, y, flipped);\n        return !isInCheck(color, newBoard);\n      });\n      return canTakeOrBlock;\n    });\n    if (!canRemoveObstacle) return true;\n  }\n  return false;\n};\n\n// given a color and the board\n// return if the king of that color is in check\nconst isInCheck = (color, board) => {\n  let kingCoords = null;\n  const availableMoves = [];\n\n  // create a copy\n  board = board.map((row) => [...row]);\n\n  // iterate through whole board\n  for (let i = 0; i < SIZE; i++) {\n    for (let j = 0; j < SIZE; j++) {\n      const [targetPiece, targetColor] = getPieceFromXY(i, j, board);\n\n      // skip blank tiles\n      if (!isValidPiece(targetPiece)) continue;\n\n      // get rid of unmoved flags for check\n      board[i][j] = targetPiece + '-' + targetColor;\n\n      // check opponent moves\n      if (color !== targetColor) {\n        availableMoves.push(\n          ...getAvailableMoves(targetPiece, i, j, targetColor, board, false)\n        );\n      }\n      // check for our king's position\n      else if (targetPiece === ChessEnum.KING) {\n        kingCoords = [i, j];\n      }\n    }\n  }\n  return availableMoves.some(\n    ([x, y]) => x === kingCoords[0] && y === kingCoords[1]\n  );\n};\n\n/*\n--------------------------------------------------------------------------------------\n------------------------------------ UI HELPERS --------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\n// given a coordinate, return the classname for tile color\nconst getTileColor = ([row, col]) => {\n  const name = 'tile';\n  const color = (row + col) % 2 ? 'tile-dark' : 'tile-light';\n  return `${name} ${color}`;\n};\n\n// given active piece coordinates, current coordinates, and available moves\n// return whether this tile should be highlighted\nconst isActiveTile = ([activeRow, activeCol], [row, col], availableMoves) => {\n  return (\n    (row === activeRow && col === activeCol) ||\n    availableMoves.some(([x, y]) => x === row && y === col)\n  );\n};\n\n// given piece name and color, return the src for associated svg\nconst getImageSrc = (piece, color) => {\n  const key = piece + color.charAt(0).toUpperCase() + color.slice(1);\n  return SVGMap[key];\n};\n\n/*\n--------------------------------------------------------------------------------------\n---------------------------------- MOVEMENT LOGIC ------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\n// given coordinates, select piece if possible\nconst choosePiece = ([row, col], props) => {\n  // destructuring\n  const [board] = props.boardHandler;\n  const [isWhiteMove] = props.turnHandler;\n  const [, setActiveTile] = props.activeHandler;\n  const [, setAvailableMoves] = props.previewHandler;\n  const [piece, color] = getPieceFromXY(row, col, board);\n\n  // if no piece at this location, stop\n  if (!isValidPiece(piece)) {\n    setActiveTile(null);\n    setAvailableMoves([]);\n    return;\n  }\n\n  // if user selects one of their pieces, make it active\n  const targetColor = isWhiteMove ? ChessEnum.LIGHT : ChessEnum.DARK;\n  if (color === targetColor) {\n    setActiveTile([row, col]);\n    setAvailableMoves(getAvailableMoves(piece, row, col, color, board));\n  }\n};\n\n// given coordinates, try to move piece if possible\nconst movePiece = ([rowInit, colInit], [rowDest, colDest], props) => {\n  // destructuring\n  const [isWhiteMove, setIsWhiteMove] = props.turnHandler;\n  const [boardState, setBoardState] = props.boardHandler;\n  const [, setActiveTile] = props.activeHandler;\n  const [, setAvailableMoves] = props.previewHandler;\n  const [, setPromotionTile] = props.promotionHandler;\n\n  // deselect if choosing same highlighted piece\n  if (rowInit === rowDest && colInit === colDest) {\n    setActiveTile(null);\n    setAvailableMoves([]);\n    return;\n  }\n\n  // check if valid move for this piece\n  const [piece, color] = getPieceFromXY(rowInit, colInit, boardState);\n  const availableMoves = getAvailableMoves(\n    piece,\n    rowInit,\n    colInit,\n    color,\n    boardState\n  );\n  const isValidMove = availableMoves.some(\n    ([x, y]) => x === rowDest && y === colDest\n  );\n\n  // if valid, change board, else deselect\n  if (isValidMove) {\n    // get new updated board\n    const newBoard = generateNewBoard(\n      rowInit,\n      colInit,\n      rowDest,\n      colDest,\n      boardState\n    );\n\n    // add en passant (board is now flipped)\n    if (piece === ChessEnum.PAWN && rowDest === rowInit - 2) {\n      newBoard[2][SIZE - 1 - colDest] = 'enpassant-' + color;\n    }\n\n    // add castling (board is now flipped)\n    if (\n      piece === ChessEnum.KING &&\n      [colInit - 2, colInit + 2].includes(colDest)\n    ) {\n      const direction = colDest < colInit ? 1 : -1;\n      const rookCol = colDest < colInit ? SIZE - 1 : 0;\n      newBoard[0][rookCol] = null;\n      newBoard[0][SIZE - 1 - (colDest + direction)] =\n        ChessEnum.ROOK + '-' + color;\n    }\n\n    // add promotion (board is now flipped)\n    if (piece === ChessEnum.PAWN && rowDest === 0) {\n      setActiveTile(null);\n      setAvailableMoves([]);\n      setBoardState(flipBoard(newBoard));\n      setPromotionTile([rowDest, colDest]);\n      return;\n    }\n\n    // change state\n    setActiveTile(null);\n    setAvailableMoves([]);\n    setBoardState(newBoard);\n    setIsWhiteMove(!isWhiteMove);\n  } else {\n    choosePiece([rowDest, colDest], props);\n  }\n};\n\n/*\n--------------------------------------------------------------------------------------\n-------------------------------------- EXPORTS ---------------------------------------\n--------------------------------------------------------------------------------------\n*/\n\nexport {\n  // CONSTANTS\n  ChessEnum,\n  DEFAULT,\n  // FUNCTIONS\n  flipBoard,\n  isActiveTile,\n  isCheckMate,\n  isInCheck,\n  isOutOfBounds,\n  isValidPiece,\n  getImageSrc,\n  getPieceFromXY,\n  getTileColor,\n  generateNewBoard,\n  // MOVEMENT\n  choosePiece,\n  movePiece,\n};\n","import React, { useState } from 'react';\nimport * as ChessPageUtils from './utils/ChessPageUtils';\nimport { ChessEnum } from './utils/ChessPageConstants';\n\nconst ChessPiece = ({ piece, color, isDraggable }) => {\n  if (!ChessPageUtils.isValidPiece(piece)) return null;\n  return (\n    <img\n      className=\"chess-piece\"\n      draggable={isDraggable}\n      src={ChessPageUtils.getImageSrc(piece, color)}\n      alt=\"chess piece\"\n    />\n  );\n};\n\nconst PromotionModal = ({ color, promotionClickHandler }) => {\n  return (\n    <div className=\"mask\">\n      <div className=\"promotion-modal\">\n        {[\n          ChessEnum.QUEEN,\n          ChessEnum.KNIGHT,\n          ChessEnum.ROOK,\n          ChessEnum.BISHOP,\n        ].map((piece) => (\n          <div\n            className=\"modal-tile\"\n            onClick={() => promotionClickHandler(piece, color)}\n          >\n            <img\n              className=\"modal-pieces\"\n              draggable={false}\n              src={ChessPageUtils.getImageSrc(piece, color)}\n              alt=\"chess piece\"\n            />\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nconst Board = () => {\n  const [isWhiteMove, setIsWhiteMove] = useState(true);\n  const [boardState, setBoardState] = useState(ChessPageUtils.DEFAULT);\n  const [activeTile, setActiveTile] = useState(null);\n  const [availableMoves, setAvailableMoves] = useState([]);\n  const [hoveredTile, setHoveredTile] = useState(null);\n  const [isCheck, setIsCheck] = useState(false);\n  const [isCheckMate, setIsCheckMate] = useState(false);\n  const [promotionTile, setPromotionTile] = useState(null); // CHANGE THIS\n\n  const props = {\n    turnHandler: [isWhiteMove, setIsWhiteMove],\n    boardHandler: [boardState, setBoardState],\n    activeHandler: [activeTile, setActiveTile],\n    previewHandler: [availableMoves, setAvailableMoves],\n    promotionHandler: [promotionTile, setPromotionTile],\n  };\n\n  let text = (\n    <div className=\"turn-text\">\n      {isCheck && <span style={{ color: 'red' }}>CHECK: </span>}\n      <span className=\"highlight\">{isWhiteMove ? 'WHITE' : 'BLACK'}</span> to\n      move!\n    </div>\n  );\n\n  if (isCheckMate)\n    text = (\n      <div className=\"turn-text\">\n        <span style={{ color: 'CornflowerBlue' }}>\n          {isWhiteMove ? 'BLACK' : 'WHITE'} WINS!\n        </span>\n      </div>\n    );\n\n  const promotionClickHandler = (piece, color) => {\n    const [x, y] = promotionTile;\n    const copy = boardState.map((row) => [...row]);\n    copy[x][y] = piece + '-' + color;\n\n    // change state\n    setPromotionTile(null);\n    setBoardState(ChessPageUtils.flipBoard(copy));\n    setIsWhiteMove(!isWhiteMove);\n  };\n\n  return (\n    <div className=\"board\">\n      {text}\n      {promotionTile && (\n        <PromotionModal\n          color={isWhiteMove ? ChessEnum.LIGHT : ChessEnum.DARK}\n          promotionClickHandler={promotionClickHandler}\n        />\n      )}\n      {boardState.map((pieces, row) => (\n        <div key={row} className=\"board-row\">\n          {pieces.map((_, col) => {\n            // get info about this tile\n            const currentTile = [row, col];\n            const [name, color] = ChessPageUtils.getPieceFromXY(\n              ...currentTile,\n              boardState\n            );\n            const isActive =\n              activeTile &&\n              ChessPageUtils.isActiveTile(\n                activeTile,\n                currentTile,\n                availableMoves\n              );\n            const isHovered =\n              hoveredTile &&\n              ChessPageUtils.isActiveTile(hoveredTile, currentTile, []);\n            const isDraggable =\n              (isWhiteMove && color === ChessEnum.LIGHT) ||\n              (!isWhiteMove && color === ChessEnum.DARK);\n\n            // define handlers for this tile\n            const clickHandler = () => {\n              activeTile\n                ? ChessPageUtils.movePiece(activeTile, currentTile, props)\n                : ChessPageUtils.choosePiece(currentTile, props);\n            };\n            const dragStartHandler = () => {\n              ChessPageUtils.choosePiece(currentTile, props);\n            };\n            const dragEnterHandler = () => {\n              setHoveredTile(currentTile);\n            };\n            const dragEndHandler = () => {\n              if (activeTile && hoveredTile) {\n                ChessPageUtils.movePiece(activeTile, hoveredTile, props);\n                setHoveredTile(null);\n              }\n            };\n\n            // check if our king is checkmated\n            if (!isCheckMate && name === ChessEnum.KING && isDraggable) {\n              // must flip board for this\n              const flipped = ChessPageUtils.flipBoard(boardState);\n\n              // check with flipped board\n              if (ChessPageUtils.isInCheck(color, flipped)) {\n                const checkmate = ChessPageUtils.isCheckMate(color, flipped);\n                if (checkmate) {\n                  if (!isCheckMate) setIsCheckMate(true);\n                } else {\n                  if (!isCheck) setIsCheck(true);\n                }\n              }\n              // not check\n              else {\n                if (isCheck) setIsCheck(false);\n              }\n            }\n\n            // render actual tile\n            return (\n              <div\n                key={col}\n                className={ChessPageUtils.getTileColor(currentTile)}\n                onClick={clickHandler}\n                onDragStart={dragStartHandler}\n                onDragEnter={dragEnterHandler}\n                onDragEnd={dragEndHandler}\n                onDragOver={(e) => e.preventDefault()}\n              >\n                {isActive && <div className=\"active\"></div>}\n                {isHovered && <div className=\"hovered\"></div>}\n                <ChessPiece\n                  piece={name}\n                  color={color}\n                  isDraggable={isDraggable}\n                />\n              </div>\n            );\n          })}\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default Board;\n","import React from 'react';\nimport Board from '../components/ChessPage/Board';\n\nconst ChessPage = () => (\n  <div className=\"chess-page\">\n    <Board />\n  </div>\n);\n\nexport default ChessPage;\n","import React from 'react';\nimport ChessPage from './views/ChessPage';\nimport './styles/css/App.scss';\n\nconst App = () => {\n  return (\n    <div className=\"ultra\">\n      <ChessPage />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}